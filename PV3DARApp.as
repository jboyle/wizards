package {	// test	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Rectangle;		import org.libspark.flartoolkit.core.transmat.FLARTransMatResult;	import org.libspark.flartoolkit.detector.FLARMultiMarkerDetectorResult;	import org.libspark.flartoolkit.support.pv3d.FLARBaseNode;	import org.libspark.flartoolkit.support.pv3d.FLARCamera3D;	import org.papervision3d.render.LazyRenderEngine;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.view.Viewport3D;		public class PV3DARApp extends ARAppBase {			protected var _base:Sprite;		public static var globalBase:Sprite;			public static var globalBitmap:Bitmap;		public static var globalBitmapData:BitmapData;				public static var gIsFirstDetectionDone:Boolean;		public static var _detectedMarkers:Array;	// array of FLARDetectedMarkerInfo		public static var _detectedNumFinal:Array;	// array of detected marker's index				protected var _viewport:Viewport3D;		protected var _camera3d:FLARCamera3D;		protected var _scene:Scene3D;		protected var _renderer:LazyRenderEngine;		protected var _markerNode:FLARBaseNode;			//protected var _markerNodeMulti:Array;	// array of FLARBaseNode		//protected var _markerNodeMulti:FLARBaseNode;		protected var _detectedInfo:Array;		// array of FLARMultiMarkerDetectorResult		protected var detected:Boolean;		protected var detectedNum:int;		protected var _maxMarkerNum:int;	// const		//protected var _detectedResults:FLARMultiMarkerDetectorResult;		protected var _resultMat:FLARTransMatResult;// = new FLARTransMatResult();				/*public function get detectedNumFinal():int		{			return _detectedNumFinal;		}*/				public function PV3DARApp() {		}				protected override function init(cameraFile:String, codeFile:String, canvasWidth:int = 400, canvasHeight:int = 300, codeWidth:int = 60):void {			//_markerNodeMulti = null;			_maxMarkerNum = 0;			addEventListener(Event.INIT, _onInit, false, int.MAX_VALUE);			super.init(cameraFile, codeFile, canvasWidth, canvasHeight, codeWidth);		}				protected override function initM(cameraFile:String, codeFileArray:Array, canvasWidth:int = 400, canvasHeight:int = 300, codeWidth:int = 60):void {			_maxMarkerNum=20;	// max 20 markers			_detectedMarkers = new Array();			_detectedNumFinal = new Array();						addEventListener(Event.INIT, _onInit, false, int.MAX_VALUE);			super.initM(cameraFile, codeFileArray, canvasWidth, canvasHeight, codeWidth);		}				private function _onInit(e:Event):void {			_base = addChild(new Sprite()) as Sprite;			//test			globalBase = _base;						_capture.width = 800;//640;			_capture.height = 600;//480;			_base.addChild(_capture);						detected = false;	// protected var detected:Boolean;						// what's Viewport3D() ??????		//	_viewport = _base.addChild(new Viewport3D(320, 240)) as Viewport3D;			_viewport = _base.addChild(new Viewport3D(400, 300)) as Viewport3D;			_viewport.scaleX = 800/400;//640 / 320;				_viewport.scaleY = 600/300;//480 / 240;			_viewport.x = -4; // 4pix ???						_camera3d = new FLARCamera3D(_param);						_scene = new Scene3D();			_markerNode = _scene.addChild(new FLARBaseNode()) as FLARBaseNode;						_renderer = new LazyRenderEngine(_scene, _camera3d, _viewport);						// test			/////////////////////////////////////////////////////////////			globalBitmapData = new BitmapData(400, 300, false, 0x00);			globalBitmap = new Bitmap(globalBitmapData);			globalBitmap.name = "tempbitmap";			_base.addChild(globalBitmap);			gIsFirstDetectionDone = false;			/////////////////////////////////////////////////////////////						addEventListener(Event.ENTER_FRAME, _onEnterFrame);		}				private function _onEnterFrame(e:Event = null):void {			_capture.bitmapData.draw(_video);			trace("Current FPS: "+_webcam.currentFPS);								try {				//detected = _detector.detectMarkerLite(_raster, 70) && _detector.getConfidence() > 0.5;				//detectedNum = _detectorMulti.detectMarkerLite(_raster, 70);// && _detectorMulti.getConfidence()>0.5;	//70:threshold				detectedNum = _detectorMulti.detectMarkerLite(_raster, -1);				//detected = _detector.detectMarker(_raster, 80) && _detector.getConfidence()>0.5;							} catch (e:Error) {}						// test (drawing captured+thresholded image)			//////////////////////////////////////////////////////////////////			var tmp:DisplayObject;			tmp = globalBase.removeChildAt(globalBase.getChildIndex(globalBase.getChildByName("tempbitmap")));			tmp = null;	// free ?			globalBitmapData = _detectorMulti.thresholdedBitmapData.clone();			//FLARRaster_BitmapData(this._bin_raster).bitmapData.clone();			for(var n:int=0; n<3; n++)		// drawing reference markers			{				var t_patArray:Array = _codeArray[n].getPat();				for (var y:int=0; y<16; y++)					for(var x:int=0; x<16; x++)					{						var color:uint = uint(t_patArray[0][y][x][0]<<16 | t_patArray[0][y][x][1]<<8 | t_patArray[0][y][x][2]);						globalBitmapData.fillRect(new Rectangle(x*5+320, y*5+(n*82), 5, 5), color);					}			}			////////////////////////////////////////////////////////////////////////						_detectedNumFinal = new Array();	// clear array						if(detectedNum>0)			{				var i:int;								for(i=0; i<detectedNum; i++)				{					if(_detectorMulti.getConfidence(i) > 0.6)					{						gIsFirstDetectionDone = true;												_resultMat = new FLARTransMatResult();						_detectorMulti.getTransmationMatrix(i, _resultMat);								//trace("result mat at PV3DARApp: "+_resultMat);						//trace("AR code index: "+ _markerNum);												var temp:FLARMultiMarkerDetectorResult = _detectorMulti.getResult(i);						var tempResult:FLARDetectedMarkerInfo = new FLARDetectedMarkerInfo(temp.codeId,																							temp.direction,																							temp.confidence,																							temp.square,																							_resultMat);						_detectedMarkers[_detectedNumFinal.length] = tempResult;	// garbage collection ? 						//_detectedMarkers[i] = tempResult;	// garbage collection ?						//trace(tempResult);						_detectedNumFinal.push(temp.codeId);							// test: drawing detected marker image						///////////////////////////////////////////////////////////						t_patArray = _detectorMulti._patt.getPatArray();						for (y=0; y<16; y++)							for(x=0; x<16; x++)							{								color = uint(t_patArray[y][x][0]<<16 | t_patArray[y][x][1]<<8 | t_patArray[y][x][2]);								globalBitmapData.fillRect(new Rectangle(x*5, y*5, 5, 5), color);							}							var xx:int; var yy:int;							for(var ii:int=0; ii<4; ii++)	// drawing vertex							{								xx=_detectorMulti.getResult(i).square.imvertex[ii].x-2;								yy=_detectorMulti.getResult(i).square.imvertex[ii].y-2;								globalBitmapData.fillRect(new Rectangle(xx, yy, 5, 5), 0xff0000);							}						///////////////////////////////////////////////////////////					}				}			}								// test			/////////////////////////////////////////////////////////			globalBitmap = new Bitmap(globalBitmapData);			globalBitmap.name = "tempbitmap";			globalBase.addChild(globalBitmap);			/////////////////////////////////////////////////////////						// single marker//			if (detected) {//				_detector.getTransformMatrix(_resultMat);//				_markerNode.setTransformMatrix(_resultMat);	// ???????????????????????????????//				//_markerNode.setTransformMatrixDummy(_resultMat);//				_resultMat.getRotationAngle();	// for Z axis//				_resultMat.getIntersectionPoints2();//				trace(_resultMat.intersectionX+" "+_resultMat.intersectionY+"\n");////				//using papervision3d api//				/*var baseRotation:Number3D = Matrix3D.matrix2euler(_markerNode.transform);//				trace("from papervision3D api");//				trace(baseRotation.x+" "+baseRotation.y+" "+baseRotation.z);*///				//				_markerNode.visible = true;//			} else {//				_markerNode.visible = false;//			}			//////////////////////			_renderer.render();			//////////////////////		}				public function set mirror(value:Boolean):void {			if (value) {				_base.scaleX = -1;				_base.x = 800;//640;			} else {				_base.scaleX = 1;				_base.x = 0;			}		}				public function get mirror():Boolean {			return _base.scaleX < 0;		}	}}
