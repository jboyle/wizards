package com.wizards{	import com.wizards.effects.Damage;	import com.wizards.effects.Effect;	import com.wizards.effects.HitPoints;	import com.wizards.effects.ModifyingEffect;		public class SpellFactory	{		//private var _spellData:XMLList;		public static var spellData:XMLList;		/*public function SpellFactory(data:XMLList)		{			_spellData = data;		}*/				public static function createSpell(name:String):Spell{			trace("creating "+name+" spell");			var ret:Spell = new Spell(name);			var effectData:XMLList = WizardsG.SPELLS[name];			for each(var effect in effectData.children()){				ret.addEffect(createEffect(effect));			}			return ret;		}				public static function createEffect(effectData:XML):Effect{			var ret:Effect;			trace("\tcauses "+effectData.name.toString()+" effect");			switch(effectData.name.toString()){				case "Damage":					ret = new Damage(Number(effectData.amount),getEffectMatch(effectData.match.toString()),getEffectAffect(effectData.affect.toString()), getEffectDuration(effectData.duration.toString()), uint(effectData.priority));					break;				case "HitPoints":					ret = new HitPoints(Number(effectData.hitPoints), getEffectDuration(effectData.duration.toString()), uint(effectData.priority));					break;			}			//add attach			//trace("spell attach: "+effectData.attach.toString());			ret.attach = getEffectAttach(effectData.attach.toString());			//add duration			if(ret.duration == Effect.DURATION_TIMED){				ret.time = Number(effectData.time);			}			//add tags			ret.addTags(getTagArray(effectData.tags.toString()));			var me:ModifyingEffect = ret as ModifyingEffect;			if(me != null){				me.addSearchTags(getTagArray(effectData.searchTags.toString()));			}			return ret;		}				public static function getEffectDuration(duration:String):uint{			var ret:uint = Effect.DURATION_SINGLE;			switch(duration){				case "timed":					ret = Effect.DURATION_TIMED;					break;				case "depleted":					ret = Effect.DURATION_DEPLETED;					break;				case "forever":					ret = Effect.DURATION_FOREVER;					break;				}			return ret;		}				public static function getEffectMatch(match:String):uint{			var ret:uint = Effect.MATCH_ONE;			switch(match){				case "all":					ret = Effect.MATCH_ALL;					break				case "perfect":					ret = Effect.MATCH_PERFECT;					break;			}			return ret;		}				public static function getEffectAffect(affect:String):uint{			var ret:uint = ModifyingEffect.AFFECT_FIRST;			if(affect == "all"){				ret = ModifyingEffect.AFFECT_ALL;			}			return ret;		}				public static function getEffectAttach(attach:String):uint{			var ret:uint = Effect.ATTACH_ONCE;			if(attach == "hold"){				ret = Effect.ATTACH_HOLD;			}			return ret;		}				public static function getTagArray(tagString:String){			return tagString.split(" ");		}	}}