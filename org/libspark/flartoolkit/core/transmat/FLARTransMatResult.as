/*  * PROJECT: FLARToolKit * -------------------------------------------------------------------------------- * This work is based on the NyARToolKit developed by *   R.Iizuka (nyatla) * http://nyatla.jp/nyatoolkit/ * * The FLARToolKit is ActionScript 3.0 version ARToolkit class library. * Copyright (C)2008 Saqoosha * * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with this framework; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  * For further information please contact. *	http://www.libspark.org/wiki/saqoosha/FLARToolKit *	<saq(at)saqoosha.net> *  */package org.libspark.flartoolkit.core.transmat {	import flash.system.*;		import org.libspark.flartoolkit.core.transmat.rotmatrix.FLARRotMatrix;	import org.libspark.flartoolkit.core.types.FLARDoublePoint3d;	import org.libspark.flartoolkit.core.types.matrix.FLARDoubleMatrix34;	import org.papervision3d.core.math.Number3D;		/**	 * FLARTransMat戻り値専用のFLARMat	 * 	 */	public class FLARTransMatResult extends FLARDoubleMatrix34 {		private var has_value:Boolean = false;		private var RADIAN_TO_DEGREE:Number = 180/Math.PI;		private var DEGREE_TO_RADIAN:Number = Math.PI/180;				public var rotationX:Number;		public var rotationY:Number;		public var rotationZ:Number;		public var rotationXDegree:Number;		public var rotationYDegree:Number;		public var rotationZDegree:Number;		public var intersectionX:Number;		public var intersectionY:Number;				/**		 * パラメータで変換行列を更新します。		 * 		 * @param i_rot		 * @param i_off		 * @param i_trans		 */		public function updateMatrixValue(i_rot:FLARRotMatrix, i_off:FLARDoublePoint3d, i_trans:FLARDoublePoint3d):void {			this.m00 = i_rot.m00;			this.m01 = i_rot.m01;			this.m02 = i_rot.m02;			this.m03 = i_rot.m00 * i_off.x + i_rot.m01 * i_off.y + i_rot.m02 * i_off.z + i_trans.x;			this.m10 = i_rot.m10;			this.m11 = i_rot.m11;			this.m12 = i_rot.m12;			this.m13 = i_rot.m10 * i_off.x + i_rot.m11 * i_off.y + i_rot.m12 * i_off.z + i_trans.y;			this.m20 = i_rot.m20;			this.m21 = i_rot.m21;			this.m22 = i_rot.m22;			this.m23 = i_rot.m20 * i_off.x + i_rot.m21 * i_off.y + i_rot.m22 * i_off.z + i_trans.z;			this.has_value = true;			return;		}		public function hasValue():Boolean {			return this.has_value;		}		/*		var fm:FLARDoubleMatrix34		rotationX = Math.atan2(fm.m20, fm.m22); 		rotationY = Math.asin(-fm.m21); 		rotationZ = Math.atan2(fm.m01, -fm.m11);		*/		public function getRotationAngle():void		{			rotationX = Math.atan2(this.m20, this.m22);			rotationY = Math.asin(-1*this.m21);			rotationZ = Math.atan2(this.m01, -1*this.m11);						rotationXDegree = rotationX*RADIAN_TO_DEGREE;			rotationYDegree = rotationY*RADIAN_TO_DEGREE;			rotationZDegree = rotationZ*RADIAN_TO_DEGREE;		}				public function getIntersectionPoints():void		{	// Z=0			intersectionX = -1*this.m23*(Math.sin(rotationY))/(Math.cos(rotationX)*Math.cos(rotationY)) + this.m03;			intersectionX = int(intersectionX);			intersectionY = this.m23*(Math.sin(rotationX)*Math.cos(rotationY))/(Math.cos(rotationX)*Math.cos(rotationY)) + this.m13;			intersectionY = int(intersectionY);			/*var a:Number, b:Number, c:Number;			a = -1*Math.cos(rotationX)*Math.sin(rotationY)*Math.cos(rotationZ)-Math.sin(rotationX)*Math.sin(rotationZ);			b = -1*Math.cos(rotationX)*Math.sin(rotationY)*Math.sin(rotationZ)+Math.sin(rotationX)*Math.cos(rotationZ);			c = -1*Math.cos(rotationX)*Math.cos(rotationY);						intersectionX = this.m03 - a*this.m23/c;			intersectionY = this.m13 - b*this.m23/c;*/		}				public function getIntersectionPoints2():void		{			var scale:Number=1;			var point1:Number3D = new Number3D();			//var point2:Number3D = new Number3D();			var directionVector:Number3D = new Number3D();			point1.x = this.m03;			point1.y = this.m13;			point1.z = this.m23*scale;			//point2.x = this.m02+this.m03;	point2.y = this.m12+this.m13;	point2.z = this.m22+this.m23;			//directionVector = Number3D.sub(point2, point1);			directionVector.x = this.m02; directionVector.y = this.m12; directionVector.z = this.m22;						if(directionVector.z!=0)			{				intersectionX = point1.x - (directionVector.x/directionVector.z)*point1.z;				if(intersectionX>9999)			intersectionX = 9999;				else if(intersectionX<-9999)	intersectionX = -9999;				intersectionY = point1.y - (directionVector.y/directionVector.z)*point1.z;				if(intersectionY>9999)			intersectionY = 9999;				else if(intersectionY<-9999)	intersectionY = -9999;			}			else	// infinity case	the line from the marker is parallel to the screen plane			{				intersectionX = 9999;				intersectionY = 9999;			}		}	}}